<!--
Copyright 2006-2012 Michel Casabianca <michel.casabianca@gmail.com>

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
-->

<p>This documentation is intended for people who want to develop new
packages for Bee. A package is made of tasks and eggs. Tasks may be
compared to functions that run in build files. Eggs generate new
projects interactively with the user and are similar to Rails
Scaffoldings.</p>

<h2>Template Project</h2>

<p>The fast way to start developing a new package is to run the 
<i>package</i> egg with following command line:</p>

<pre>
bee -t package
</pre>

<p>This will ask you the package name:</p>

<pre>
$ b -t package
--------------------------------------------------------------------- welcome --
This script will create a project for a bee package with sample task (in
'lib' directory) and template (in 'egg' directory). A unit test for the
task is generated in 'test' directory. Generated build file has a target
'test' to run unit tests, a target 'gem' to generate a gem archive, a
'clean' target to clean generated files and a 'install' target to build
and install gem.
---------------------------------------------------------------------- prompt --
Please answer following questions to generate the project:
What is the project's name? [bee_hello]:
</pre>

<p>Here, accept default name (<i>bee_hello</i>) pressing <tt>ENTER</tt>.
A new directory named <i>bee_hello</i> is created in current directory
that contains the generated project. Sample task is generated in file 
<i>lib/bee_task_hello.rb</i> and is the source for following task sample.
Sample egg is generated in the <i>egg</i> subdirectory.</p>

<h2>Writing Bee Tasks</h2>

<p>If you think that your preferred piece of Ruby code you run in
Bee is of interest for other users, you should probably make it a
Bee task. This is a way to make it easy to run and distribute to
other users.</p>

<p>Let's say you decide to write a Bee task from your greeting script.
This must be written in a script named <i>bee_task_hello.rb</i>, where
<tt>hello</tt> will be the package of your task. This naming scheme
that starts with <i>bee_task</i> followed by the package name is necessary
so that Bee is able to locate and load this script when a task with package 
<tt>hello</tt> is called in a build file.</p>

<p>This package will contain a single task named <tt>hello</tt> that
will greet a user which name is passed as argument to the task. You could
write this script as follows:</p>

<?include file="exp/bee_task_hello.rb"?>

<p>Your code must be embedded in a class <tt>Hello</tt> (because of
the name you choose for your package) in <tt>Bee::Task</tt> module.
This class must inherit <tt>Bee::Task::Package</tt> to be recognized
as a Bee task.</p>

<p>In this class, you will declare a method named <tt>hello</tt>, the
named of the task you want to expose. It will take the name you want
to say hello to. These methods that code a given task must always take
a single parameter that is the object resulting from the YAML parsing of
task parameters. Thus, this parameter may be a string, a list, a hash
or any other YAML type, depending on your task parameters. These
parameters are processed before calling these methods so that property
references are replaced with their values, but its up to you to
check that parameter types are correct and output an appropriate
error message if this is not the case. Note that you may code more
than one task in a given package.</p>

<p>You may call this task with following build file:</p>

<?include file="exp/developerguide-task-hello.yml"?>

<p>Which will output, as expected:</p>

<?run command="bee -s ll:80 -f exp/developerguide-task-hello.yml hello"
      print="bee hello"?>

<p>Of course, you must put the Ruby script for your task somewhere in
your Ruby path so that it can be found. The best way to distribute a
Bee task is probably building a Ruby Gem. This is done by the build file
generated by <i>package</i> egg, running target <tt>gem</tt>. This
build file is also able to run unit tests in the generated 
<i>test/tc_bee_task_hello.rb</i> by running target <tt>test</tt>.</p>

<p>Tasks are self documented. To get help about a task <i>foo.bar</i>,
simply type <tt>bee -k foo.bar</tt> and you get this task documentation
on the terminal. This works also for tasks you write. Simply write this
documentation as the method help. Ruby will parse this comment and print
it on the standard output. This help should always describe your task
parameters and provide a short sample, as in the example we've seen
above. Install generated gem for the template project, typing 
<tt>bee install</tt> in the template project directory. When typing
<tt>bee -k hello.hello</tt>, you get the following help page:</p>

<pre>
$ bee -k hello.hello
----------------------------------------------------------------- hello.hello --
Sample hello task that prints greeting message on console.

- who: who to greet.

Example

 - hello.hello: "World"
</pre>
<!--
<run command="bee -s ll:80 -k hello.hello"
      print="bee -k hello.hello"?>
-->

<p>This feature is quite convenient for people who write build files
and thus tasks coders should take care of properly documenting their
tasks.</p>

<h2>Writing Bee Eggs</h2>

<p>An egg is a script that the user launches to generate interactively
a new project. This is very handy to quickly have a running project to
start working with. We've seen above that there is an egg to generate
a template project for a Bee packages.</p>

<p>In a nutshell, eggs are Bee build files that ask the user for pieces
of information, such as the project name, and generate the template in a
subdirectory.</p>

<p>Let's say we have just discovered the power of Ruby Gems and want to
distribute our scripts packaged as ready to install gems. We could write
an egg to generate template projects to start with.</p>

<p>The first thing to do is to write a sample project that we will
package and customize in our egg. This sample project, named <i>hello</i>
might look like this:</p>

<pre>
hello
 |
 +- build.yml
 |
 +- bin
 |   |
 |   +- hello
 |
 +- lib
     |
     +- hello.rb
</pre>

<p>Our script is <i>hello.rb</i> in the <i>lib</i> directory:</p>

<?include file="exp/developerguide-egg-project-script.rb"?>

<p>To start this script as a gem, we need a launching script named
<i>hello</i> in <i>bin</i> directory. This script might look like this
one:</p>

<?include file="exp/developerguide-egg-project-launcher.rb"?>

<p>Now we need a build file to package our gem. This build file has
targets to generate the gem archive, install and uninstall it and to
clean generated files. The following one will do the job:</p>

<?include file="exp/developerguide-egg-project-build.yml"?>

<p>Now that we have a sample project, we must turn it into a template,
which means add parameters to customize it. Our script will stay the
same except that we will replace the file name with the project's name
along with an <i>.rb</i> extension while generating the target project.
The launching script must be customized so that the name of the file
to load matches the script name. We can do so making this file an
ERB file (Embedded Ruby, that is a file containing Ruby expressions
embedded in <tt>&lt;%= expression %></tt> tags). This ERB might be:</p>

<?include file="exp/developerguide-egg-erb-launcher.erb"?>

<p>While processing this file, the expression
<tt>&lt;%= project_name %></tt> will be replaced with the value of
<tt>project_name</tt> Ruby variable, which in turn will have the value
of property <tt>project_name</tt> of our build file.</p>

<p>Our build file must be customized the same way:</p>

<?include file="exp/developerguide-egg-erb-build.erb"?>

<p>Now we have all necessary pieces and just have to write a build
file to put them together. We will name this build file after the
template name (which suggests what it does). In this example, we'll
name it <i>hello</i>. Thus this build file will be named 
<i>hello.yml</i> and we will put all associated file within a 
directory named <i>hello</i>. All egg files live in a directory
named <i>egg</i> in the package directory. This convention must be
implemented so that Bee is able to find a given package in a gem
named <i>bee_&lt;package></i> and the build file to generate the
template in a directory <i>egg/&lt;name&gt;.yml</i>. Thus, the structure
of the directory of our example package is the following:</p>

<pre>
bee_&lt;package>
 |
 +- egg
     |
     +- hello.yml
     |
     +- hello
         |
         +- build.erb
         |
         +- launcher.erb
         |
         +- script.rb
</pre>

<p>The build file to generate the template might be:</p>

<?include file="exp/developerguide-egg-build.yml"?>

<p>This build file defines two properties: <tt>project_name</tt>
and <tt>description</tt> which are quiet self descriptive. Property
<tt>description</tt> is used to describe egg in command line help,
thus it should always be defined so that users may obtain a 
description of the purpose of your eggs.</p>

<p>First target, named <tt>welcome</tt>, simply prints the description
of the egg. Second target, named <tt>prompt</tt>, will ask the user for
the project's name. Target <tt>generate</tt> will generate template
project, copying the script and processig the launching script and the
build file using ERB, which will inject project's name into these
scripts. Note that before generating template project we check that
it's directory doesn't already exists to prevent an accident, 
overwriting an existing directory. Last target, named 
<i>customization</i> prints a closing message to the user.</p>

<p>The best way to test our egg is to go in the <i>egg</i> directory
and launch the build file typing <tt>bee -f hello.yml</tt>, to start
our egg's build file. This would produce:</p>

<pre>
$ bee -f hello.yml 
--------------------------------------------------------------------- welcome --
This script will create a project for a Ruby script that might be
distributed as a gem. Generated build file has a single target gem
to generate the distribution gem.
---------------------------------------------------------------------- prompt --
Please answer following questions to generate the project:
What is the project's name? [hello]:
test
-------------------------------------------------------------------- generate --
Generating project...
Creating directory 'test'
Creating directory 'test/bin'
Creating directory 'test/lib'
Processing ERB 'hello/build.erb'
Copying 1 file(s) to 'test/lib/test.rb'
Processing ERB 'hello/launcher.erb'
--------------------------------------------------------------- customization --
Project has been generated in directory 'test'. Type 'bee -b'
to print information about generated build file. Enjoy!
------------------------------------------------------------------------- all --
OK
</pre>

<p>As a result, we have a brand new customized template project in directory
<i>test</i> (the name for the generated template we entered on prompt).
This output is the one your user will see running your egg typing
<tt>bee -t hello.hello</tt>.</p>

<p>Now that you have written your package <i>hello</i>, you can distribute
it as a Ruby Gem. To generate the gem, type <tt>bee gem</tt> in your package
directory. If your gem is distributed using RubyForge, your users can install
this package with:</p>

<pre>
sudo gem install bee_hello
</pre>

<p>Else, you can distribute this gem and your users can install it locally
typing:</p>

<pre>
sudo gem install --local build/bee_hello-0.0.1.gem
</pre>

<p>Then, they will be able to use your new tasks in their build files
and generate template projects typing <tt>bee -t hello.hello</tt>.</p>

<p><i>Enjoy!</i></p>
